Index: app/src/main/java/com/atharvakale/facerecognition/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.atharvakale.facerecognition;\r\n\r\nimport android.Manifest;\r\nimport android.annotation.SuppressLint;\r\nimport android.app.Activity;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.SharedPreferences;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.res.AssetFileDescriptor;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Color;\r\nimport android.graphics.ImageFormat;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.Paint;\r\nimport android.graphics.Rect;\r\nimport android.graphics.RectF;\r\nimport android.graphics.YuvImage;\r\nimport android.media.Image;\r\nimport android.net.Uri;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\n\r\nimport androidx.annotation.NonNull;\r\n\r\nimport androidx.annotation.RequiresApi;\r\nimport androidx.appcompat.app.AlertDialog;\r\nimport androidx.camera.core.CameraSelector;\r\nimport androidx.camera.core.ImageAnalysis;\r\nimport androidx.camera.core.ImageProxy;\r\nimport androidx.camera.core.Preview;\r\nimport androidx.camera.lifecycle.ProcessCameraProvider;\r\n\r\nimport com.google.android.gms.tasks.OnCompleteListener;\r\nimport com.google.android.gms.tasks.OnFailureListener;\r\nimport com.google.android.gms.tasks.OnSuccessListener;\r\nimport com.google.android.gms.tasks.Task;\r\nimport com.google.common.util.concurrent.ListenableFuture;\r\n\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.reflect.TypeToken;\r\nimport com.google.mlkit.vision.common.InputImage;\r\nimport com.google.mlkit.vision.face.Face;\r\nimport com.google.mlkit.vision.face.FaceDetection;\r\nimport com.google.mlkit.vision.face.FaceDetector;\r\nimport com.google.mlkit.vision.face.FaceDetectorOptions;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.camera.view.PreviewView;\r\nimport androidx.core.content.ContextCompat;\r\nimport androidx.lifecycle.LifecycleOwner;\r\n\r\nimport android.os.ParcelFileDescriptor;\r\nimport android.text.InputType;\r\nimport android.util.Pair;\r\nimport android.util.Size;\r\nimport android.view.View;\r\n\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.ImageButton;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport org.tensorflow.lite.Interpreter;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.FileDescriptor;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.ByteOrder;\r\nimport java.nio.MappedByteBuffer;\r\nimport java.nio.ReadOnlyBufferException;\r\nimport java.nio.channels.FileChannel;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.Executor;\r\nimport java.util.concurrent.Executors;\r\n\r\npublic class MainActivity extends AppCompatActivity {\r\n    FaceDetector detector;\r\n\r\n    private ListenableFuture<ProcessCameraProvider> cameraProviderFuture;\r\n    PreviewView previewView;\r\n    ImageView face_preview;\r\n    Interpreter tfLite;\r\n    TextView reco_name,preview_info,textAbove_preview;\r\n    Button recognize,camera_switch, actions;\r\n    ImageButton add_face;\r\n    CameraSelector cameraSelector;\r\n    boolean developerMode=false;\r\n    float distance= 1.0f;\r\n    boolean start=true,flipX=false;\r\n    Context context=MainActivity.this;\r\n    int cam_face=CameraSelector.LENS_FACING_BACK; //Default Back Camera\r\n\r\n    int[] intValues;\r\n    int inputSize=112;  //Input size for model\r\n    boolean isModelQuantized=false;\r\n    float[][] embeedings;\r\n    float IMAGE_MEAN = 128.0f;\r\n    float IMAGE_STD = 128.0f;\r\n    int OUTPUT_SIZE=192; //Output size of model\r\n    private static int SELECT_PICTURE = 1;\r\n    ProcessCameraProvider cameraProvider;\r\n    private static final int MY_CAMERA_REQUEST_CODE = 100;\r\n\r\n    String modelFile=\"mobile_face_net.tflite\"; //model name\r\n\r\n    private HashMap<String, SimilarityClassifier.Recognition> registered = new HashMap<>(); //saved Faces\r\n    @RequiresApi(api = Build.VERSION_CODES.M)\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        registered=readFromSP(); //Load saved faces from memory when app starts\r\n        setContentView(R.layout.activity_main);\r\n        face_preview =findViewById(R.id.imageView);\r\n        reco_name =findViewById(R.id.textView);\r\n        preview_info =findViewById(R.id.textView2);\r\n        textAbove_preview =findViewById(R.id.textAbovePreview);\r\n        add_face=findViewById(R.id.imageButton);\r\n        add_face.setVisibility(View.INVISIBLE);\r\n\r\n        SharedPreferences sharedPref = getSharedPreferences(\"Distance\",Context.MODE_PRIVATE);\r\n        distance = sharedPref.getFloat(\"distance\",1.00f);\r\n\r\n        face_preview.setVisibility(View.INVISIBLE);\r\n        recognize=findViewById(R.id.button3);\r\n        camera_switch=findViewById(R.id.button5);\r\n        actions=findViewById(R.id.button2);\r\n        textAbove_preview.setText(\"Recognized Face:\");\r\n//        preview_info.setText(\"        Recognized Face:\");\r\n        //Camera Permission\r\n        if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {\r\n            requestPermissions(new String[]{Manifest.permission.CAMERA}, MY_CAMERA_REQUEST_CODE);\r\n        }\r\n        //On-screen Action Button\r\n        actions.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\r\n                builder.setTitle(\"Select Action:\");\r\n\r\n                // add a checkbox list\r\n                String[] names= {\"View Recognition List\",\"Update Recognition List\",\"Save Recognitions\",\"Load Recognitions\",\"Clear All Recognitions\",\"Import Photo (Beta)\"};\r\n\r\n                builder.setItems(names, new DialogInterface.OnClickListener() {\r\n                    @Override\r\n                    public void onClick(DialogInterface dialog, int which) {\r\n\r\n                        switch (which)\r\n                        {\r\n                            case 0:\r\n                                displaynameListview();\r\n                                break;\r\n                            case 1:\r\n                                updatenameListview();\r\n                                break;\r\n                            case 2:\r\n                                insertToSP(registered,0); //mode: 0:save all, 1:clear all, 2:update all\r\n                                break;\r\n                            case 3:\r\n                                registered.putAll(readFromSP());\r\n                                break;\r\n                            case 4:\r\n                                clearnameList();\r\n                                break;\r\n                            case 5:\r\n                                loadphoto();\r\n                                break;\r\n                        }\r\n\r\n                    }\r\n                });\r\n\r\n\r\n                builder.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\r\n                    @Override\r\n                    public void onClick(DialogInterface dialog, int which) {\r\n\r\n                    }\r\n                });\r\n                builder.setNegativeButton(\"Cancel\", null);\r\n\r\n                // create and show the alert dialog\r\n                AlertDialog dialog = builder.create();\r\n                dialog.show();\r\n            }\r\n        });\r\n\r\n        //On-screen switch to toggle between Cameras.\r\n        camera_switch.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                if (cam_face==CameraSelector.LENS_FACING_BACK) {\r\n                    cam_face = CameraSelector.LENS_FACING_FRONT;\r\n                    flipX=true;\r\n                }\r\n                else {\r\n                    cam_face = CameraSelector.LENS_FACING_BACK;\r\n                    flipX=false;\r\n                }\r\n                cameraProvider.unbindAll();\r\n                cameraBind();\r\n            }\r\n        });\r\n\r\n        add_face.setOnClickListener((new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n\r\n                addFace();\r\n            }\r\n        }));\r\n\r\n\r\n        recognize.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                if(recognize.getText().toString().equals(\"Recognize\"))\r\n                {\r\n                 start=true;\r\n                 textAbove_preview.setText(\"Recognized Face:\");\r\n                recognize.setText(\"Add Face\");\r\n                add_face.setVisibility(View.INVISIBLE);\r\n                reco_name.setVisibility(View.VISIBLE);\r\n                face_preview.setVisibility(View.INVISIBLE);\r\n                preview_info.setText(\"\");\r\n                //preview_info.setVisibility(View.INVISIBLE);\r\n                }\r\n                else\r\n                {\r\n                    textAbove_preview.setText(\"Face Preview: \");\r\n                    recognize.setText(\"Recognize\");\r\n                    add_face.setVisibility(View.VISIBLE);\r\n                    reco_name.setVisibility(View.INVISIBLE);\r\n                    face_preview.setVisibility(View.VISIBLE);\r\n                    preview_info.setText(\"1.Bring Face in view of Camera.\\n\\n2.Your Face preview will appear here.\\n\\n3.Click Add button to save face.\");\r\n\r\n\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n        //Load model\r\n        try {\r\n            tfLite=new Interpreter(loadModelFile(MainActivity.this,modelFile));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        //Initialize Face Detector\r\n        FaceDetectorOptions highAccuracyOpts =\r\n                new FaceDetectorOptions.Builder()\r\n                        .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_ACCURATE)\r\n                        .build();\r\n        detector = FaceDetection.getClient(highAccuracyOpts);\r\n\r\n        cameraBind();\r\n    }\r\n\r\n    private void addFace()\r\n    {\r\n        {\r\n\r\n            start=false;\r\n            AlertDialog.Builder builder = new AlertDialog.Builder(context);\r\n            builder.setTitle(\"Enter Name\");\r\n\r\n                // Set up the input\r\n            final EditText input = new EditText(context);\r\n\r\n            input.setInputType(InputType.TYPE_CLASS_TEXT );\r\n            builder.setView(input);\r\n\r\n                // Set up the buttons\r\n            builder.setPositiveButton(\"ADD\", new DialogInterface.OnClickListener() {\r\n                @Override\r\n                public void onClick(DialogInterface dialog, int which) {\r\n                    //Toast.makeText(context, input.getText().toString(), Toast.LENGTH_SHORT).show();\r\n\r\n                    //Create and Initialize new object with Face embeddings and Name.\r\n                    SimilarityClassifier.Recognition result = new SimilarityClassifier.Recognition(\r\n                            \"0\", \"\", -1f);\r\n                    result.setExtra(embeedings);\r\n\r\n                    registered.put( input.getText().toString(),result);\r\n                    start=true;\r\n\r\n                }\r\n            });\r\n            builder.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\r\n                @Override\r\n                public void onClick(DialogInterface dialog, int which) {\r\n                    start=true;\r\n                    dialog.cancel();\r\n                }\r\n            });\r\n\r\n            builder.show();\r\n        }\r\n    }\r\n    private  void clearnameList()\r\n    {\r\n        AlertDialog.Builder builder =new AlertDialog.Builder(context);\r\n        builder.setTitle(\"Do you want to delete all Recognitions?\");\r\n        builder.setPositiveButton(\"Delete All\", new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                registered.clear();\r\n                Toast.makeText(context, \"Recognitions Cleared\", Toast.LENGTH_SHORT).show();\r\n            }\r\n        });\r\n        insertToSP(registered,1);\r\n        builder.setNegativeButton(\"Cancel\",null);\r\n        AlertDialog dialog = builder.create();\r\n        dialog.show();\r\n    }\r\n    private void updatenameListview()\r\n    {\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(context);\r\n        if(registered.isEmpty()) {\r\n            builder.setTitle(\"No Faces Added!!\");\r\n            builder.setPositiveButton(\"OK\",null);\r\n        }\r\n        else{\r\n            builder.setTitle(\"Select Recognition to delete:\");\r\n\r\n        // add a checkbox list\r\n        String[] names= new String[registered.size()];\r\n        boolean[] checkedItems = new boolean[registered.size()];\r\n         int i=0;\r\n                for (Map.Entry<String, SimilarityClassifier.Recognition> entry : registered.entrySet())\r\n                {\r\n                    //System.out.println(\"NAME\"+entry.getKey());\r\n                    names[i]=entry.getKey();\r\n                    checkedItems[i]=false;\r\n                    i=i+1;\r\n\r\n                }\r\n\r\n                builder.setMultiChoiceItems(names, checkedItems, new DialogInterface.OnMultiChoiceClickListener() {\r\n                    @Override\r\n                    public void onClick(DialogInterface dialog, int which, boolean isChecked) {\r\n                        // user checked or unchecked a box\r\n                        //Toast.makeText(MainActivity.this, names[which], Toast.LENGTH_SHORT).show();\r\n                       checkedItems[which]=isChecked;\r\n\r\n                    }\r\n                });\r\n\r\n\r\n        builder.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n\r\n                       // System.out.println(\"status:\"+ Arrays.toString(checkedItems));\r\n                        for(int i=0;i<checkedItems.length;i++)\r\n                        {\r\n                            //System.out.println(\"status:\"+checkedItems[i]);\r\n                            if(checkedItems[i])\r\n                            {\r\n//                                Toast.makeText(MainActivity.this, names[i], Toast.LENGTH_SHORT).show();\r\n                                registered.remove(names[i]);\r\n                            }\r\n\r\n                        }\r\n                insertToSP(registered,2); //mode: 0:save all, 1:clear all, 2:update all\r\n                Toast.makeText(context, \"Recognitions Updated\", Toast.LENGTH_SHORT).show();\r\n            }\r\n        });\r\n        builder.setNegativeButton(\"Cancel\", null);\r\n\r\n        // create and show the alert dialog\r\n        AlertDialog dialog = builder.create();\r\n        dialog.show();\r\n    }\r\n    }\r\n    private void hyperparameters()\r\n    {\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(context);\r\n        builder.setTitle(\"Euclidean Distance\");\r\n        builder.setMessage(\"0.00 -> Perfect Match\\n1.00 -> Default\\nTurn On Developer Mode to find optimum value\\n\\nCurrent Value:\");\r\n        // Set up the input\r\n        final EditText input = new EditText(context);\r\n\r\n        input.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);\r\n        builder.setView(input);\r\n        SharedPreferences sharedPref = getSharedPreferences(\"Distance\",Context.MODE_PRIVATE);\r\n        distance = sharedPref.getFloat(\"distance\",1.00f);\r\n        input.setText(String.valueOf(distance));\r\n        // Set up the buttons\r\n        builder.setPositiveButton(\"Update\", new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                //Toast.makeText(context, input.getText().toString(), Toast.LENGTH_SHORT).show();\r\n\r\n               distance= Float.parseFloat(input.getText().toString());\r\n\r\n\r\n                SharedPreferences sharedPref = getSharedPreferences(\"Distance\",Context.MODE_PRIVATE);\r\n                SharedPreferences.Editor editor = sharedPref.edit();\r\n                editor.putFloat(\"distance\", distance);\r\n                editor.apply();\r\n\r\n            }\r\n        });\r\n        builder.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n\r\n                dialog.cancel();\r\n            }\r\n        });\r\n\r\n        builder.show();\r\n    }\r\n\r\n\r\n    private void displaynameListview()\r\n    {\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(context);\r\n       // System.out.println(\"Registered\"+registered);\r\n        if(registered.isEmpty())\r\n            builder.setTitle(\"No Faces Added!!\");\r\n        else\r\n            builder.setTitle(\"Recognitions:\");\r\n\r\n        // add a checkbox list\r\n        String[] names= new String[registered.size()];\r\n        boolean[] checkedItems = new boolean[registered.size()];\r\n        int i=0;\r\n        for (Map.Entry<String, SimilarityClassifier.Recognition> entry : registered.entrySet())\r\n        {\r\n            //System.out.println(\"NAME\"+entry.getKey());\r\n            names[i]=entry.getKey();\r\n            checkedItems[i]=false;\r\n            i=i+1;\r\n\r\n        }\r\n        builder.setItems(names,null);\r\n\r\n\r\n\r\n        builder.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n\r\n            }\r\n        });\r\n\r\n            // create and show the alert dialog\r\n        AlertDialog dialog = builder.create();\r\n        dialog.show();\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        if (requestCode == MY_CAMERA_REQUEST_CODE) {\r\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                Toast.makeText(this, \"camera permission granted\", Toast.LENGTH_LONG).show();\r\n            } else {\r\n                Toast.makeText(this, \"camera permission denied\", Toast.LENGTH_LONG).show();\r\n            }\r\n        }\r\n    }\r\n\r\n    private MappedByteBuffer loadModelFile(Activity activity, String MODEL_FILE) throws IOException {\r\n        AssetFileDescriptor fileDescriptor = activity.getAssets().openFd(MODEL_FILE);\r\n        FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor());\r\n        FileChannel fileChannel = inputStream.getChannel();\r\n        long startOffset = fileDescriptor.getStartOffset();\r\n        long declaredLength = fileDescriptor.getDeclaredLength();\r\n        return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength);\r\n    }\r\n\r\n    //Bind camera and preview view\r\n    private void cameraBind()\r\n    {\r\n        cameraProviderFuture = ProcessCameraProvider.getInstance(this);\r\n\r\n        previewView=findViewById(R.id.previewView);\r\n        cameraProviderFuture.addListener(() -> {\r\n            try {\r\n                cameraProvider = cameraProviderFuture.get();\r\n\r\n                bindPreview(cameraProvider);\r\n            } catch (ExecutionException | InterruptedException e) {\r\n                // No errors need to be handled for this in Future.\r\n                // This should never be reached.\r\n            }\r\n        }, ContextCompat.getMainExecutor(this));\r\n    }\r\n    void bindPreview(@NonNull ProcessCameraProvider cameraProvider) {\r\n        Preview preview = new Preview.Builder()\r\n                .build();\r\n\r\n        cameraSelector = new CameraSelector.Builder()\r\n                .requireLensFacing(cam_face)\r\n                .build();\r\n\r\n        preview.setSurfaceProvider(previewView.getSurfaceProvider());\r\n        ImageAnalysis imageAnalysis =\r\n                new ImageAnalysis.Builder()\r\n                        .setTargetResolution(new Size(640, 480))\r\n                        .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST) //Latest frame is shown\r\n                        .build();\r\n\r\n        Executor executor = Executors.newSingleThreadExecutor();\r\n        imageAnalysis.setAnalyzer(executor, new ImageAnalysis.Analyzer() {\r\n            @Override\r\n            public void analyze(@NonNull ImageProxy imageProxy) {\r\n                try {\r\n                    Thread.sleep(0);  //Camera preview refreshed every 10 millisec(adjust as required)\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                InputImage image = null;\r\n\r\n\r\n                @SuppressLint(\"UnsafeExperimentalUsageError\")\r\n                // Camera Feed-->Analyzer-->ImageProxy-->mediaImage-->InputImage(needed for ML kit face detection)\r\n\r\n                Image mediaImage = imageProxy.getImage();\r\n\r\n                if (mediaImage != null) {\r\n                    image = InputImage.fromMediaImage(mediaImage, imageProxy.getImageInfo().getRotationDegrees());\r\n//                    System.out.println(\"Rotation \"+imageProxy.getImageInfo().getRotationDegrees());\r\n                }\r\n\r\n                //Process acquired image to detect faces\r\n                Task<List<Face>> result =\r\n                        detector.process(image)\r\n                                .addOnSuccessListener(\r\n                                        new OnSuccessListener<List<Face>>() {\r\n                                            @Override\r\n                                            public void onSuccess(List<Face> faces) {\r\n\r\n                                                if(faces.size()!=0) {\r\n\r\n                                                    Face face = faces.get(0); //Get first face from detected faces\r\n//                                                    System.out.println(face);\r\n\r\n                                                    //mediaImage to Bitmap\r\n                                                    Bitmap frame_bmp = toBitmap(mediaImage);\r\n\r\n                                                    int rot = imageProxy.getImageInfo().getRotationDegrees();\r\n\r\n                                                    //Adjust orientation of Face\r\n                                                    Bitmap frame_bmp1 = rotateBitmap(frame_bmp, rot, false, false);\r\n\r\n\r\n\r\n                                                    //Get bounding box of face\r\n                                                    RectF boundingBox = new RectF(face.getBoundingBox());\r\n\r\n                                                    //Crop out bounding box from whole Bitmap(image)\r\n                                                    Bitmap cropped_face = getCropBitmapByCPU(frame_bmp1, boundingBox);\r\n\r\n                                                    if(flipX)\r\n                                                        cropped_face = rotateBitmap(cropped_face, 0, flipX, false);\r\n                                                    //Scale the acquired Face to 112*112 which is required input for model\r\n                                                    Bitmap scaled = getResizedBitmap(cropped_face, 112, 112);\r\n\r\n                                                    if(start)\r\n                                                        recognizeImage(scaled); //Send scaled bitmap to create face embeddings.\r\n//                                                    System.out.println(boundingBox);\r\n\r\n                                                }\r\n                                                else\r\n                                                {\r\n                                                    if(registered.isEmpty())\r\n                                                        reco_name.setText(\"Add Face\");\r\n                                                    else\r\n                                                        reco_name.setText(\"No Face Detected!\");\r\n                                                }\r\n\r\n                                            }\r\n                                        })\r\n                                .addOnFailureListener(\r\n                                        new OnFailureListener() {\r\n                                            @Override\r\n                                            public void onFailure(@NonNull Exception e) {\r\n                                                // Task failed with an exception\r\n                                                // ...\r\n                                            }\r\n                                        })\r\n                                .addOnCompleteListener(new OnCompleteListener<List<Face>>() {\r\n                            @Override\r\n                            public void onComplete(@NonNull Task<List<Face>> task) {\r\n\r\n                                imageProxy.close(); //v.important to acquire next frame for analysis\r\n                            }\r\n                        });\r\n            }\r\n        });\r\n        cameraProvider.bindToLifecycle((LifecycleOwner) this, cameraSelector, imageAnalysis, preview);\r\n    }\r\n\r\n    public void recognizeImage(final Bitmap bitmap) {\r\n\r\n        // set Face to Preview\r\n        face_preview.setImageBitmap(bitmap);\r\n\r\n        //Create ByteBuffer to store normalized image\r\n\r\n        ByteBuffer imgData = ByteBuffer.allocateDirect(1 * inputSize * inputSize * 3 * 4);\r\n\r\n        imgData.order(ByteOrder.nativeOrder());\r\n\r\n        intValues = new int[inputSize * inputSize];\r\n\r\n        //get pixel values from Bitmap to normalize\r\n        bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\r\n\r\n        imgData.rewind();\r\n\r\n        for (int i = 0; i < inputSize; ++i) {\r\n            for (int j = 0; j < inputSize; ++j) {\r\n                int pixelValue = intValues[i * inputSize + j];\r\n                if (isModelQuantized) {\r\n                    // Quantized model\r\n                    imgData.put((byte) ((pixelValue >> 16) & 0xFF));\r\n                    imgData.put((byte) ((pixelValue >> 8) & 0xFF));\r\n                    imgData.put((byte) (pixelValue & 0xFF));\r\n                } else { // Float model\r\n                    imgData.putFloat((((pixelValue >> 16) & 0xFF) - IMAGE_MEAN) / IMAGE_STD);\r\n                    imgData.putFloat((((pixelValue >> 8) & 0xFF) - IMAGE_MEAN) / IMAGE_STD);\r\n                    imgData.putFloat(((pixelValue & 0xFF) - IMAGE_MEAN) / IMAGE_STD);\r\n\r\n                }\r\n            }\r\n        }\r\n        //imgData is input to our model\r\n        Object[] inputArray = {imgData};\r\n\r\n        Map<Integer, Object> outputMap = new HashMap<>();\r\n\r\n\r\n        embeedings = new float[1][OUTPUT_SIZE]; //output of model will be stored in this variable\r\n\r\n        outputMap.put(0, embeedings);\r\n\r\n        tfLite.runForMultipleInputsOutputs(inputArray, outputMap); //Run model\r\n\r\n        float distance_local = Float.MAX_VALUE;\r\n        String id = \"0\";\r\n        String label = \"?\";\r\n\r\n        //Compare new face with saved Faces.\r\n        if (registered.size() > 0) {\r\n\r\n            final List<Pair<String, Float>> nearest = findNearest(embeedings[0]);//Find 2 closest matching face\r\n\r\n            if (nearest.get(0) != null) {\r\n\r\n                final String name = nearest.get(0).first; //get name and distance of closest matching face\r\n               // label = name;\r\n                distance_local = nearest.get(0).second;\r\n                if (developerMode)\r\n                {\r\n                    if(distance_local<distance) //If distance between Closest found face is more than 1.000 ,then output UNKNOWN face.\r\n                        reco_name.setText(\"Nearest: \"+name +\"\\nDist: \"+ String.format(\"%.3f\",distance_local)+\"\\n2nd Nearest: \"+nearest.get(1).first +\"\\nDist: \"+ String.format(\"%.3f\",nearest.get(1).second));\r\n                    else\r\n                        reco_name.setText(\"Unknown \"+\"\\nDist: \"+String.format(\"%.3f\",distance_local)+\"\\nNearest: \"+name +\"\\nDist: \"+ String.format(\"%.3f\",distance_local)+\"\\n2nd Nearest: \"+nearest.get(1).first +\"\\nDist: \"+ String.format(\"%.3f\",nearest.get(1).second));\r\n\r\n                }\r\n                else\r\n                {\r\n                    if(distance_local<distance) //If distance between Closest found face is more than 1.000 ,then output UNKNOWN face.\r\n                        reco_name.setText(name);\r\n                    else\r\n                        reco_name.setText(\"Unknown\");\r\n                }\r\n                }\r\n            }\r\n\r\n    }\r\n\r\n\r\n    //Compare Faces by distance between face embeddings\r\n    private List<Pair<String, Float>> findNearest(float[] emb) {\r\n        List<Pair<String, Float>> neighbour_list = new ArrayList<Pair<String, Float>>();\r\n        Pair<String, Float> ret = null; //to get closest match\r\n        Pair<String, Float> prev_ret = null; //to get second closest match\r\n        for (Map.Entry<String, SimilarityClassifier.Recognition> entry : registered.entrySet())\r\n        {\r\n\r\n            final String name = entry.getKey();\r\n           final float[] knownEmb = ((float[][]) entry.getValue().getExtra())[0];\r\n\r\n            float distance = 0;\r\n            for (int i = 0; i < emb.length; i++) {\r\n                float diff = emb[i] - knownEmb[i];\r\n                distance += diff*diff;\r\n            }\r\n            distance = (float) Math.sqrt(distance);\r\n            if (ret == null || distance < ret.second) {\r\n                prev_ret=ret;\r\n                ret = new Pair<>(name, distance);\r\n            }\r\n        }\r\n        if(prev_ret==null) prev_ret=ret;\r\n        neighbour_list.add(ret);\r\n        neighbour_list.add(prev_ret);\r\n\r\n        return neighbour_list;\r\n\r\n    }\r\n    public Bitmap getResizedBitmap(Bitmap bm, int newWidth, int newHeight) {\r\n        int width = bm.getWidth();\r\n        int height = bm.getHeight();\r\n        float scaleWidth = ((float) newWidth) / width;\r\n        float scaleHeight = ((float) newHeight) / height;\r\n        // CREATE A MATRIX FOR THE MANIPULATION\r\n        Matrix matrix = new Matrix();\r\n        // RESIZE THE BIT MAP\r\n        matrix.postScale(scaleWidth, scaleHeight);\r\n\r\n        // \"RECREATE\" THE NEW BITMAP\r\n        Bitmap resizedBitmap = Bitmap.createBitmap(\r\n                bm, 0, 0, width, height, matrix, false);\r\n        bm.recycle();\r\n        return resizedBitmap;\r\n    }\r\n    private static Bitmap getCropBitmapByCPU(Bitmap source, RectF cropRectF) {\r\n        Bitmap resultBitmap = Bitmap.createBitmap((int) cropRectF.width(),\r\n                (int) cropRectF.height(), Bitmap.Config.ARGB_8888);\r\n        Canvas cavas = new Canvas(resultBitmap);\r\n\r\n        // draw background\r\n        Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG);\r\n        paint.setColor(Color.WHITE);\r\n        cavas.drawRect(\r\n                new RectF(0, 0, cropRectF.width(), cropRectF.height()),\r\n                paint);\r\n\r\n        Matrix matrix = new Matrix();\r\n        matrix.postTranslate(-cropRectF.left, -cropRectF.top);\r\n\r\n        cavas.drawBitmap(source, matrix, paint);\r\n\r\n        if (source != null && !source.isRecycled()) {\r\n            source.recycle();\r\n        }\r\n\r\n        return resultBitmap;\r\n    }\r\n\r\n    private static Bitmap rotateBitmap(\r\n            Bitmap bitmap, int rotationDegrees, boolean flipX, boolean flipY) {\r\n        Matrix matrix = new Matrix();\r\n\r\n        // Rotate the image back to straight.\r\n        matrix.postRotate(rotationDegrees);\r\n\r\n        // Mirror the image along the X or Y axis.\r\n        matrix.postScale(flipX ? -1.0f : 1.0f, flipY ? -1.0f : 1.0f);\r\n        Bitmap rotatedBitmap =\r\n                Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);\r\n\r\n        // Recycle the old bitmap if it has changed.\r\n        if (rotatedBitmap != bitmap) {\r\n            bitmap.recycle();\r\n        }\r\n        return rotatedBitmap;\r\n    }\r\n\r\n    //IMPORTANT. If conversion not done ,the toBitmap conversion does not work on some devices.\r\n    private static byte[] YUV_420_888toNV21(Image image) {\r\n\r\n        int width = image.getWidth();\r\n        int height = image.getHeight();\r\n        int ySize = width*height;\r\n        int uvSize = width*height/4;\r\n\r\n        byte[] nv21 = new byte[ySize + uvSize*2];\r\n\r\n        ByteBuffer yBuffer = image.getPlanes()[0].getBuffer(); // Y\r\n        ByteBuffer uBuffer = image.getPlanes()[1].getBuffer(); // U\r\n        ByteBuffer vBuffer = image.getPlanes()[2].getBuffer(); // V\r\n\r\n        int rowStride = image.getPlanes()[0].getRowStride();\r\n        assert(image.getPlanes()[0].getPixelStride() == 1);\r\n\r\n        int pos = 0;\r\n\r\n        if (rowStride == width) { // likely\r\n            yBuffer.get(nv21, 0, ySize);\r\n            pos += ySize;\r\n        }\r\n        else {\r\n            long yBufferPos = -rowStride; // not an actual position\r\n            for (; pos<ySize; pos+=width) {\r\n                yBufferPos += rowStride;\r\n                yBuffer.position((int) yBufferPos);\r\n                yBuffer.get(nv21, pos, width);\r\n            }\r\n        }\r\n\r\n        rowStride = image.getPlanes()[2].getRowStride();\r\n        int pixelStride = image.getPlanes()[2].getPixelStride();\r\n\r\n        assert(rowStride == image.getPlanes()[1].getRowStride());\r\n        assert(pixelStride == image.getPlanes()[1].getPixelStride());\r\n\r\n        if (pixelStride == 2 && rowStride == width && uBuffer.get(0) == vBuffer.get(1)) {\r\n            // maybe V an U planes overlap as per NV21, which means vBuffer[1] is alias of uBuffer[0]\r\n            byte savePixel = vBuffer.get(1);\r\n            try {\r\n                vBuffer.put(1, (byte)~savePixel);\r\n                if (uBuffer.get(0) == (byte)~savePixel) {\r\n                    vBuffer.put(1, savePixel);\r\n                    vBuffer.position(0);\r\n                    uBuffer.position(0);\r\n                    vBuffer.get(nv21, ySize, 1);\r\n                    uBuffer.get(nv21, ySize + 1, uBuffer.remaining());\r\n\r\n                    return nv21; // shortcut\r\n                }\r\n            }\r\n            catch (ReadOnlyBufferException ex) {\r\n                // unfortunately, we cannot check if vBuffer and uBuffer overlap\r\n            }\r\n\r\n            // unfortunately, the check failed. We must save U and V pixel by pixel\r\n            vBuffer.put(1, savePixel);\r\n        }\r\n\r\n        // other optimizations could check if (pixelStride == 1) or (pixelStride == 2),\r\n        // but performance gain would be less significant\r\n\r\n        for (int row=0; row<height/2; row++) {\r\n            for (int col=0; col<width/2; col++) {\r\n                int vuPos = col*pixelStride + row*rowStride;\r\n                nv21[pos++] = vBuffer.get(vuPos);\r\n                nv21[pos++] = uBuffer.get(vuPos);\r\n            }\r\n        }\r\n\r\n        return nv21;\r\n    }\r\n\r\n    private Bitmap toBitmap(Image image) {\r\n\r\n        byte[] nv21=YUV_420_888toNV21(image);\r\n\r\n\r\n        YuvImage yuvImage = new YuvImage(nv21, ImageFormat.NV21, image.getWidth(), image.getHeight(), null);\r\n\r\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        yuvImage.compressToJpeg(new Rect(0, 0, yuvImage.getWidth(), yuvImage.getHeight()), 75, out);\r\n\r\n        byte[] imageBytes = out.toByteArray();\r\n\r\n        return BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.length);\r\n    }\r\n\r\n    //Save Faces to Shared Preferences.Conversion of Recognition objects to json string\r\n    private void insertToSP(HashMap<String, SimilarityClassifier.Recognition> jsonMap,int mode) {\r\n        if(mode==1)  //mode: 0:save all, 1:clear all, 2:update all\r\n            jsonMap.clear();\r\n        else if (mode==0)\r\n            jsonMap.putAll(readFromSP());\r\n        String jsonString = new Gson().toJson(jsonMap);\r\n        SharedPreferences sharedPreferences = getSharedPreferences(\"HashMap\", MODE_PRIVATE);\r\n        SharedPreferences.Editor editor = sharedPreferences.edit();\r\n        editor.putString(\"map\", jsonString);\r\n        //System.out.println(\"Input josn\"+jsonString.toString());\r\n        editor.apply();\r\n        Toast.makeText(context, \"Recognitions Saved\", Toast.LENGTH_SHORT).show();\r\n    }\r\n\r\n    //Load Faces from Shared Preferences.Json String to Recognition object\r\n    private HashMap<String, SimilarityClassifier.Recognition> readFromSP(){\r\n        SharedPreferences sharedPreferences = getSharedPreferences(\"HashMap\", MODE_PRIVATE);\r\n        String defValue = new Gson().toJson(new HashMap<String, SimilarityClassifier.Recognition>());\r\n        String json=sharedPreferences.getString(\"map\",defValue);\r\n        TypeToken<HashMap<String,SimilarityClassifier.Recognition>> token = new TypeToken<HashMap<String,SimilarityClassifier.Recognition>>() {};\r\n        HashMap<String,SimilarityClassifier.Recognition> retrievedMap=new Gson().fromJson(json,token.getType());\r\n        for (Map.Entry<String, SimilarityClassifier.Recognition> entry : retrievedMap.entrySet())\r\n        {\r\n            float[][] output=new float[1][OUTPUT_SIZE];\r\n            ArrayList arrayList= (ArrayList) entry.getValue().getExtra();\r\n            arrayList = (ArrayList) arrayList.get(0);\r\n            for (int counter = 0; counter < arrayList.size(); counter++) {\r\n                output[0][counter]= ((Double) arrayList.get(counter)).floatValue();\r\n            }\r\n            entry.getValue().setExtra(output);\r\n\r\n            //System.out.println(\"Entry output \"+entry.getKey()+\" \"+entry.getValue().getExtra() );\r\n\r\n        }\r\n//        System.out.println(\"OUTPUT\"+ Arrays.deepToString(outut));\r\n        Toast.makeText(context, \"Recognitions Loaded\", Toast.LENGTH_SHORT).show();\r\n        return retrievedMap;\r\n    }\r\n\r\n    //Load Photo from phone storage\r\n    private void loadphoto()\r\n    {\r\n        start=false;\r\n        Intent intent = new Intent();\r\n        intent.setType(\"image/*\");\r\n        intent.setAction(Intent.ACTION_GET_CONTENT);\r\n        startActivityForResult(Intent.createChooser(intent, \"Select Picture\"), SELECT_PICTURE);\r\n    }\r\n\r\n    //Similar Analyzing Procedure\r\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n        super.onActivityResult(requestCode, resultCode, data);\r\n        if (resultCode == RESULT_OK) {\r\n            if (requestCode == SELECT_PICTURE) {\r\n                Uri selectedImageUri = data.getData();\r\n                try {\r\n                    InputImage impphoto=InputImage.fromBitmap(getBitmapFromUri(selectedImageUri),0);\r\n                    detector.process(impphoto).addOnSuccessListener(new OnSuccessListener<List<Face>>() {\r\n                        @Override\r\n                        public void onSuccess(List<Face> faces) {\r\n\r\n                            if(faces.size()!=0) {\r\n                                recognize.setText(\"Recognize\");\r\n                                add_face.setVisibility(View.VISIBLE);\r\n                                reco_name.setVisibility(View.INVISIBLE);\r\n                                face_preview.setVisibility(View.VISIBLE);\r\n                                preview_info.setText(\"1.Bring Face in view of Camera.\\n\\n2.Your Face preview will appear here.\\n\\n3.Click Add button to save face.\");\r\n                                Face face = faces.get(0);\r\n\r\n                                //write code to recreate bitmap from source\r\n                                //Write code to show bitmap to canvas\r\n\r\n                                Bitmap frame_bmp= null;\r\n                                try {\r\n                                    frame_bmp = getBitmapFromUri(selectedImageUri);\r\n                                } catch (IOException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                                Bitmap frame_bmp1 = rotateBitmap(frame_bmp, 0, flipX, false);\r\n\r\n                                //face_preview.setImageBitmap(frame_bmp1);\r\n\r\n\r\n                                RectF boundingBox = new RectF(face.getBoundingBox());\r\n\r\n\r\n                                Bitmap cropped_face = getCropBitmapByCPU(frame_bmp1, boundingBox);\r\n\r\n                                Bitmap scaled = getResizedBitmap(cropped_face, 112, 112);\r\n                                // face_preview.setImageBitmap(scaled);\r\n\r\n                                    recognizeImage(scaled);\r\n                                    addFace();\r\n//                                System.out.println(boundingBox);\r\n                                try {\r\n                                    Thread.sleep(100);\r\n                                } catch (InterruptedException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            }\r\n                        }\r\n                    }).addOnFailureListener(new OnFailureListener() {\r\n                        @Override\r\n                        public void onFailure(@NonNull Exception e) {\r\n                            start=true;\r\n                            Toast.makeText(context, \"Failed to add\", Toast.LENGTH_SHORT).show();\r\n                        }\r\n                    });\r\n                    face_preview.setImageBitmap(getBitmapFromUri(selectedImageUri));\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n    private Bitmap getBitmapFromUri(Uri uri) throws IOException {\r\n        ParcelFileDescriptor parcelFileDescriptor =\r\n                getContentResolver().openFileDescriptor(uri, \"r\");\r\n        FileDescriptor fileDescriptor = parcelFileDescriptor.getFileDescriptor();\r\n        Bitmap image = BitmapFactory.decodeFileDescriptor(fileDescriptor);\r\n        parcelFileDescriptor.close();\r\n        return image;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/atharvakale/facerecognition/MainActivity.java b/app/src/main/java/com/atharvakale/facerecognition/MainActivity.java
--- a/app/src/main/java/com/atharvakale/facerecognition/MainActivity.java	
+++ b/app/src/main/java/com/atharvakale/facerecognition/MainActivity.java	
@@ -385,46 +385,6 @@
         dialog.show();
     }
     }
-    private void hyperparameters()
-    {
-        AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        builder.setTitle("Euclidean Distance");
-        builder.setMessage("0.00 -> Perfect Match\n1.00 -> Default\nTurn On Developer Mode to find optimum value\n\nCurrent Value:");
-        // Set up the input
-        final EditText input = new EditText(context);
-
-        input.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
-        builder.setView(input);
-        SharedPreferences sharedPref = getSharedPreferences("Distance",Context.MODE_PRIVATE);
-        distance = sharedPref.getFloat("distance",1.00f);
-        input.setText(String.valueOf(distance));
-        // Set up the buttons
-        builder.setPositiveButton("Update", new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialog, int which) {
-                //Toast.makeText(context, input.getText().toString(), Toast.LENGTH_SHORT).show();
-
-               distance= Float.parseFloat(input.getText().toString());
-
-
-                SharedPreferences sharedPref = getSharedPreferences("Distance",Context.MODE_PRIVATE);
-                SharedPreferences.Editor editor = sharedPref.edit();
-                editor.putFloat("distance", distance);
-                editor.apply();
-
-            }
-        });
-        builder.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialog, int which) {
-
-                dialog.cancel();
-            }
-        });
-
-        builder.show();
-    }
-
 
     private void displaynameListview()
     {
Index: app/src/main/java/com/atharvakale/facerecognition/splash_screen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.atharvakale.facerecognition;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\n\r\npublic class splash_screen extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_splash_screen);\r\n        Handler handler = new Handler();\r\n        handler.postDelayed(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                Intent intent = new Intent(splash_screen.this, MainActivity.class);\r\n                finish();\r\n                startActivity(intent);\r\n            }\r\n        }, 2500);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/atharvakale/facerecognition/splash_screen.java b/app/src/main/java/com/atharvakale/facerecognition/splash_screen.java
--- a/app/src/main/java/com/atharvakale/facerecognition/splash_screen.java	
+++ b/app/src/main/java/com/atharvakale/facerecognition/splash_screen.java	
@@ -16,7 +16,7 @@
         handler.postDelayed(new Runnable() {
             @Override
             public void run() {
-                Intent intent = new Intent(splash_screen.this, MainActivity.class);
+                Intent intent = new Intent(splash_screen.this, uploadimage.class);
                 finish();
                 startActivity(intent);
             }
